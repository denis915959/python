# python imulator.txt

import sys
import codecs #для считывания русских символов
import sqlite3
import copy
import time
import random
from paho.mqtt import client as mqtt_client
from PyQt5.QtWidgets import QApplication, QDesktopWidget, QFileDialog, QVBoxLayout, QMainWindow, QPushButton, QLineEdit, QWidget, QLabel, QGroupBox, QGridLayout, QMenuBar, QAction, QInputDialog, QMessageBox
from PyQt5.QtGui import QFont
from collections import namedtuple

edge = namedtuple('edge', ['n1', 'n2'])

class Mesh:
	def __init__(self, m_number, m_artikul):
		self.number=m_number
		self.articul=m_artikul

class Branch:
	def __init__(self, adjacted_node1, cost1):
		self.adjacted_node=adjacted_node1
		self.cost=cost1

class Node:
	def __init__(self, num, branch_arr, flag1):
		self.number=num
		self.branch_array=branch_arr
		self.crossroad=flag1 #True - Перекресток, нет - рядом с ячейками находится
		self.traveled_path=0
		self.previous_node=-1

class robot_path_node:
	def __init__(self, action1, counter1):
		self.action=action1
		self.counter=counter1


class Sklad:
	def __init__(self, mode, M, N_sizes, cost_between_blocks, cost_between_rows, cost_between_mesh, number_to_zero_node, max_floor, orientation):
		self.mode = mode
		self.M = M
		self.N_sizes = N_sizes
		self.cost_between_blocks = cost_between_blocks
		self.cost_between_rows = cost_between_rows
		self.cost_between_mesh = cost_between_mesh
		self.number_to_zero_node = number_to_zero_node
		self.orientation = orientation
		self.Nodes=[]
		if(self.mode==1):
			self.N_size=sum(self.N_sizes) + len(self.N_sizes) + 1
		if(self.mode==2):
			self.N_size=sum(self.N_sizes) + len(self.N_sizes) - 1
		self.count_of_mesh = sum(self.N_sizes)*M
		self.max_floor=max_floor
		self.list=[]
		self.generate_graf()
		

	def generate_graf(self):  #генерация графа
		sz=len(self.N_sizes)
		count=0
		if(self.mode==1):  #число перекрестков в ряде стеллажей
			N_size=sum(self.N_sizes)+len(self.N_sizes) + 1 #число перекрестков в ряде стеллажей
			b=[]
			b.append(Branch(self.number_to_zero_node, self.cost_between_rows))
			self.Nodes.append(Node(count, b, True))
	
			for i in range(0, int(self.M/2)):
				#формируем левую магистраль!
				if(i==0):
					count=count+1
					branchs=[]
					if(i==(int(self.M/2)-1)):
						branchs=[Branch(count+1, self.cost_between_blocks)]
					else:
						branchs=[Branch(count+1, self.cost_between_blocks), Branch(count+N_size, self.cost_between_rows)]
					self.Nodes.append(Node(count, branchs, True))
				else:
					count=count+1
					branchs=[]
					if(i==(int(self.M/2)-1)):
						branchs=[Branch(count+1, self.cost_between_blocks), Branch(count-N_size, self.cost_between_rows)]
					else:
						branchs=[Branch(count+1, self.cost_between_blocks), Branch(count-N_size, self.cost_between_rows), Branch(count+N_size, self.cost_between_rows)]
					self.Nodes.append(Node(count, branchs, True))
	
				#формируем перекрестки в самом первом блоке.
				if(self.N_sizes[0]==1): #блок из одной ячейки!
					count=count+1
					branchs=[Branch(count+1, self.cost_between_blocks), Branch(count-1, self.cost_between_blocks)] #добавлено
					self.Nodes.append(Node(count, branchs, False))
				else:
					for j in range(0, self.N_sizes[0]):
						count=count+1
						branchs=[]
						if(j==0): # первый перекресток в блоке
							branchs=[Branch(count+1, self.cost_between_mesh), Branch(count-1, self.cost_between_blocks)] #добавлено
						if(j==(self.N_sizes[0]-1)): # последний перекресток в блоке
							branchs=[Branch(count-1, self.cost_between_mesh), Branch(count+1, self.cost_between_blocks)]
						if((j!=(self.N_sizes[0]-1))and(j!=0)): # обычный перекресток в середине
							branchs=[Branch(count-1, self.cost_between_mesh), Branch(count+1, self.cost_between_mesh)]
						self.Nodes.append(Node(count, branchs, False))
				
				for k in range(1, sz): #идем по блокам
					#создаем перекресток на главной диагонали
					count=count+1
					flag=False
					if((i==0)and(int(self.M/2)==1)): #т.е если это испытательный стенд
						branchs=[Branch(count+1, self.cost_between_blocks), Branch(count-1, self.cost_between_blocks)]
						flag=True
					if((i==0)and(int(self.M/2)>1)): #т.е если это НЕ испытательный стенд, первый ряд
						branchs=[Branch(count+1, self.cost_between_blocks), Branch(count-1, self.cost_between_blocks), Branch(count+N_size, self.cost_between_rows)]
						flag=True
					if((i!=0)and(i==(int(self.M/2)-1))): #последний ряд
						branchs=[Branch(count+1, self.cost_between_blocks), Branch(count-1, self.cost_between_blocks), Branch(count-N_size, self.cost_between_rows)]
						flag=True
					if(flag==False): #т.е это обычный перекресток в середине склада
						branchs=[Branch(count+1, self.cost_between_blocks), Branch(count-1, self.cost_between_blocks), Branch(count-N_size, self.cost_between_rows), Branch(count+N_size, self.cost_between_rows)]
					self.Nodes.append(Node(count, branchs, True))
	
					# создаем сам блок
					for j in range(0, self.N_sizes[k]):
						count=count+1
						branchs=[]
						if(self.N_sizes[k]==1): #блок из одной ячейки!
							if(k==(sz-1)): # крайний правый блок!
								branchs=[Branch(count-1, self.cost_between_blocks), Branch(count+1, self.cost_between_blocks)]
							else:
								branchs=[Branch(count-1, self.cost_between_blocks), Branch(count+1, self.cost_between_blocks)]
						
						else: 
							flag = False
							if(j==0): # первый перекресток в блоке
								branchs=[Branch(count+1, self.cost_between_mesh), Branch(count-1, self.cost_between_blocks)] #эта строка отличается от аналогичной при построении крайнего левого блока
								flag = True
							if((j==(self.N_sizes[k]-1))and(j!=0)and(k==(sz-1))): # крайний перекресток справа
								branchs=[Branch(count-1, self.cost_between_mesh), Branch(count+1, self.cost_between_blocks)] #добавлено
								flag = True
							elif((j==(self.N_sizes[k]-1))and(j!=0)): #крайний перекресток в блоке, но не крайнем блоке!
								branchs=[Branch(count-1, self.cost_between_mesh), Branch(count+1, self.cost_between_blocks)]
								flag = True 
							if(flag==False):    #((j!=(self.N_sizes[0]-1))and(j!=0)): #обычный перекресток внутри блока
								branchs=[Branch(count-1, self.cost_between_mesh), Branch(count+1, self.cost_between_mesh)]
						self.Nodes.append(Node(count, branchs, False))
	
				#формируем правую магистраль!
				if(i==0):
					count=count+1
					branchs=[]
					if(i==(int(self.M/2)-1)):
						branchs=[Branch(count-1, self.cost_between_blocks)]
					else:
						branchs=[Branch(count-1, self.cost_between_blocks), Branch(count+N_size, self.cost_between_rows)]
					self.Nodes.append(Node(count, branchs, True))
				else:
					count=count+1
					branchs=[]
					if(i==(int(self.M/2)-1)):
						branchs=[Branch(count-1, self.cost_between_blocks), Branch(count-N_size, self.cost_between_rows)]
					else:
						branchs=[Branch(count-1, self.cost_between_blocks), Branch(count-N_size, self.cost_between_rows), Branch(count+N_size, self.cost_between_rows)]
					self.Nodes.append(Node(count, branchs, True))
			self.Nodes[self.number_to_zero_node].branch_array.append(Branch(0, self.cost_between_rows))
	
		if (self.mode==2):
			N_size=sum(self.N_sizes)+len(self.N_sizes)-1 #число перекрестков в ряде стеллажей
			b=[]
			b.append(Branch(self.number_to_zero_node, self.cost_between_rows))
			self.Nodes.append(Node(count, b, True))
	
			for i in range(0, int(self.M/2)):
				#формируем перекрестки в самом первом блоке.
				if(self.N_sizes[0]==1):
					count=count+1
					branchs=[Branch(count+1, self.cost_between_blocks)]
					self.Nodes.append(Node(count, branchs, False))
				else:
					for j in range(0, self.N_sizes[0]):
						count=count+1
						branchs=[]
						if(j==0): # первый перекресток в блоке
							branchs=[Branch(count+1, self.cost_between_mesh)]
						if(j==(self.N_sizes[0]-1)): # последний перекресток в блоке
							branchs=[Branch(count-1, self.cost_between_mesh), Branch(count+1, self.cost_between_blocks)]
						if((j!=(self.N_sizes[0]-1))and(j!=0)):
							branchs=[Branch(count-1, self.cost_between_mesh), Branch(count+1, self.cost_between_mesh)]
						self.Nodes.append(Node(count, branchs, False))
				
				for k in range(1, sz): #идем по блокам
					#создаем перекресток на главной диагонали
					count=count+1
					flag=False
					if((i==0)and(int(self.M/2)==1)): #т.е если это испытательный стенд
						branchs=[Branch(count+1, self.cost_between_blocks), Branch(count-1, self.cost_between_blocks)]
						flag=True
					if((i==0)and(int(self.M/2)>1)): #т.е если это НЕ испытательный стенд, первый ряд
						branchs=[Branch(count+1, self.cost_between_blocks), Branch(count-1, self.cost_between_blocks), Branch(count+N_size, self.cost_between_rows)]
						flag=True
					if((i!=0)and(i==(int(self.M/2)-1))): #последний ряд
						branchs=[Branch(count+1, self.cost_between_blocks), Branch(count-1, self.cost_between_blocks), Branch(count-N_size, self.cost_between_rows)]
						flag=True
					if(flag==False): #т.е это обычный перекресток в середине склада
						branchs=[Branch(count+1, self.cost_between_blocks), Branch(count-1, self.cost_between_blocks), Branch(count-N_size, self.cost_between_rows), Branch(count+N_size, self.cost_between_rows)]
					self.Nodes.append(Node(count, branchs, True))
	
					# создаем сам блок
					for j in range(0, self.N_sizes[k]):
						count=count+1
						branchs=[]
						if(self.N_sizes[k]==1):
							if(k==(sz-1)): 
								branchs=[Branch(count-1, self.cost_between_blocks)]
							else:
								branchs=[Branch(count-1, self.cost_between_blocks), Branch(count+1, self.cost_between_blocks)]
						
						else: 
							flag = False
							if(j==0): # первый перекресток в блоке
								branchs=[Branch(count+1, self.cost_between_mesh), Branch(count-1, self.cost_between_blocks)] #эта строка отличается от аналогичной при построении крайнего левого блока
								flag = True
							if((j==(self.N_sizes[k]-1))and(j!=0)and(k==(sz-1))): # крайний перекресток справа
								branchs=[Branch(count-1, self.cost_between_mesh)] #, Branch(count+1, self.cost_between_blocks)]
								flag = True
							elif((j==(self.N_sizes[k]-1))and(j!=0)): #крайний перекресток в блоке, но не крайнем блоке!
								branchs=[Branch(count-1, self.cost_between_mesh), Branch(count+1, self.cost_between_blocks)]
								flag = True 
							if(flag==False):    #((j!=(self.N_sizes[0]-1))and(j!=0)): #обычный перекресток внутри блока
								branchs=[Branch(count-1, self.cost_between_mesh), Branch(count+1, self.cost_between_mesh)]
							#if((self.N_sizes[k]==1)and(k==(sz-1))):
	
						self.Nodes.append(Node(count, branchs, False))
	
			self.Nodes[self.number_to_zero_node].branch_array.append(Branch(0, self.cost_between_rows))


	def delete_branch_from_Nodes(self, node1, node2):
		flag1=False
		if(node1<len(self.Nodes)):
			sz1=len(self.Nodes[node1].branch_array)
			for i in range(0, sz1):
				if(self.Nodes[node1].branch_array[i].adjacted_node==node2):
					del self.Nodes[node1].branch_array[i]
					flag1=True
					break
		flag2=False
		if(node2<len(self.Nodes)):
			sz2=len(self.Nodes[node2].branch_array)
			for i in range(0, sz2):
				if(self.Nodes[node2].branch_array[i].adjacted_node==node1):
					del self.Nodes[node2].branch_array[i]
					flag2=True
					break
		if((flag1==True)and(flag2==True)):
			res=True
		else:
			res=False
			if(flag1==True):
				self.Nodes[node1].branch_array.append(node2)
			if(flag2==True):
				self.Nodes[node2].branch_array.append(node1)
		return(res)


	def insert_branch_to_Nodes(self, node1, node2):#, crossroad1, crossroad2):
		res=False
		if((node1<len(self.Nodes))and(node2<len(self.Nodes))):
			crossroad1=self.Nodes[node1].crossroad
			crossroad2=self.Nodes[node2].crossroad
			if((crossroad1==True)and(crossroad2==True)):
				cost=self.cost_between_rows
			if(((crossroad1==True)and(crossroad2==False))or((crossroad2==True)and(crossroad1==False))):
				if((node1 == 0) or (node2 == 0)):
					cost = self.cost_between_rows
				else:
					cost=self.cost_between_blocks
			if((crossroad1==False)and(crossroad2==False)):
				if((node1 == 0) or (node2 == 0)):
					cost = self.cost_between_rows
				else:
					cost=self.cost_between_mesh
			self.Nodes[node1].branch_array.append(Branch(node2, cost))
			self.Nodes[node2].branch_array.append(Branch(node1, cost))
			res=True
		return(res)


	def get_crossroad(self, mesh):  # расчет номера перекрестка по номеру ячейки
		N_size_small=sum(self.N_sizes)	
		Sum=0
		sz=len(self.N_sizes)
		block_mesh=0
		mesh_tmp=mesh%N_size_small
		for i in range(0, sz):
			Sum=Sum+self.N_sizes[i]
			if(mesh_tmp<Sum):
				block_mesh=i
				break
		cross_row=0 #нумерация с нуля
		if(self.mode==2):
			cross_row=int(mesh/(2*self.N_size))
			return(cross_row*self.N_size+mesh_tmp+block_mesh+1)
		if(self.mode==1):
			cross_row=int(mesh/(2*self.N_size))
			return(cross_row*self.N_size+mesh_tmp+block_mesh+2)


	# функция выбора следующей вершины на основании расчета эвристики
	def choose_node(self, reachable, goal_node): #goal_node это объект класса Node
		sz_reachable=len(reachable)
		H=[]
		if (self.mode == 1):
			for k in range(0, sz_reachable):  #расчет эвристики в цикле между goal_node и всемы элементами массива reachable
				node1_abs=reachable[k]   #первоначальное значение
				node2_abs=goal_node      #первоначальное значение
				heuristic=0
				node1 = node1_abs.number
				node2 = node2_abs.number
				if(node2==node1):
					heuristic = 0
					H.append(heuristic+reachable[k].traveled_path)
					continue
				if(node1==0):
					node1 = self.number_to_zero_node
					heuristic = heuristic + self.cost_between_rows
				else:
					node1=(node1_abs.number-1)%self.N_size+1

				if(node2==0):
					heuristic = 0
					H.append(heuristic+reachable[k].traveled_path)
					continue
				else:
					node2=(node2_abs.number-1)%self.N_size+1	
				if ((node1_abs.number%self.N_size)>(node2_abs.number%self.N_size)):  #node1 левее node2 всегда!!!
					tmp=node1_abs
					node1_abs=node2_abs
					node2_abs=tmp
				if (node1>node2):  #node1 левее node2 всегда!!!
					tmp=node1
					node1=node2
					node2=tmp
				sz=len(self.N_sizes)
				Sum=1 
				for i in range(0, sz):
					if(node1==Sum):
						flag1=True
						block_node1=i
						break
					Sum=Sum+self.N_sizes[i]+1
					if(node1<Sum): #<=
						block_node1=i
						break
				if((node1==1)and(node2!=self.N_size)):
					block_node1=-1 
					flag1=True
				if (node1==self.N_size):
					block_node1=sz
					flag1=True
				Sum=1
		
				for i in range(0, sz):
					if(node2==Sum):
						flag2=True
						block_node2=i
						break
					Sum=Sum+self.N_sizes[i] + 1
					if(node2<Sum):
						block_node2=i
						break
				if(node2==1):  #для n2 это не актуально, так как node2>=node1
					block_node2=-1  #т.е =-1
					flag2=True
				if (node2==self.N_size):
					block_node2=sz
					flag2=True
				if((node1==1)and(node2==self.N_size)):
					block_node1=-1
				if((block_node1==block_node2)and(block_node1!=sz)and(block_node1!=-1)and(node1_abs.crossroad!=True)and(node2_abs.crossroad!=True)):
					Sum=-1
					if(block_node1==0):
						Sum=2
					else:
						Sum=2
						for j in range(0, block_node1):
							Sum=Sum+self.N_sizes[j]+1
					h1=node1-Sum
					h2=node2-Sum
					S1=h1+h2
					Sum=-1
					if(block_node1==0):
						Sum=2
					else:
						Sum=0
						for j in range(0, (block_node1+1)):
							Sum=Sum+self.N_sizes[j]+1
					h1=abs(node1-Sum)
					h2=abs(node2-Sum)

					S2=h1+h2
					if(S1>S2):
						cross_count=S2
					else:
						cross_count=S1	
					heuristic =heuristic + cross_count*self.cost_between_mesh    # heuristic=(Min-2)*self.cost_between_mesh+2*self.cost_between_blocks
					if ((node1_abs.number//self.N_size)!=(node2_abs.number//self.N_size)): #важно, чтобы перекрестки были в одно блоке!
						heuristic=heuristic+2*self.cost_between_blocks
				else:
					for j in range(node1, node2):
						if ((self.Nodes[j].crossroad==True)or(self.Nodes[j+1].crossroad==True)):  #-1
							heuristic = heuristic + self.cost_between_blocks
						if ((self.Nodes[j].crossroad==False) and (self.Nodes[j+1].crossroad==False)):  #-1
							heuristic = heuristic + self.cost_between_mesh
				row_node1=int((node1_abs.number-1)/self.N_size)
				row_node2=int((node2_abs.number-1)/self.N_size)
				row_difference=abs(row_node2-row_node1) 
				heuristic=heuristic+row_difference*self.cost_between_rows  #вернуть!	
				H.append(heuristic+reachable[k].traveled_path)

		if (self.mode == 2):
			for k in range(0, sz_reachable):  #расчет эвристики в цикле между goal_node и всемы элементами массива reachable
				node1_abs=reachable[k]  #первоначальное значение
				node2_abs=goal_node     #первоначальное значение		
				heuristic=0
				node1 = node1_abs.number
				node2 = node2_abs.number
				if(node2==node1):
					heuristic = 0
					H.append(heuristic+reachable[k].traveled_path)
					continue			
				if(node1==0):
					node1 = self.number_to_zero_node
					heuristic = heuristic + self.cost_between_rows
				else:
					node1=(node1_abs.number-1)%self.N_size+1
				if(node2==0):
					heuristic = 0
					H.append(heuristic+reachable[k].traveled_path)
					continue
				else:
					node2=(node2_abs.number-1)%self.N_size+1
				if ((node1_abs.number%self.N_size)>(node2_abs.number%self.N_size)):  #node1 левее node2 всегда!!!
					tmp=node1_abs
					node1_abs=node2_abs
					node2_abs=tmp
				if (node1>node2):  #node1 левее node2 всегда!!!
					tmp=node1
					node1=node2
					node2=tmp
				sz=len(self.N_sizes)
				#ищем номер блока ячеек, в котором находится первая вершина
				Sum=0
				block_node1=-2
				for i in range(0, sz):
					if(node1==Sum):
						flag1=True
						block_node1=i
						break
					Sum=Sum+self.N_sizes[i]+1
					if(node1<Sum): #<=
						block_node1=i
						break
				Sum=0
				block_node2=-2
				for i in range(0, sz):
					if(node2==Sum):
						flag2=True
						block_node2=i
						break
					Sum=Sum+self.N_sizes[i] + 1
					if(node2<Sum):
						block_node2=i
						break
				if((block_node1==block_node2)and(node1_abs.crossroad!=True)and(node2_abs.crossroad!=True)): #т.е перекрестки в одном блоке находятся, ни один из них не на главной магистрпали!
					cross_count=-2
					if(block_node1==0): #переписано по новой, работает на всех типах складов!
						Sum=self.N_sizes[0]
						h1=Sum - node1  #расчет номера перекрестки в блоке, содержащем этот перекресток
						h2=Sum - node2
						cross_count=h1+h2 #это костыль, чтобы не делать еще одну проверку при расчете эвристики, так как первому блоку не принадлежит ни один перекресток!
						heuristic=cross_count*self.cost_between_mesh	
					if(block_node1==(sz-1)): #переписано по новой, работает на всех типах складов!
						Sum=1
						for j in range(0, block_node1): #здесь выход за диапазон!
							Sum=Sum+self.N_sizes[j]+1
						h1=abs(node1-Sum)
						h2=abs(node2-Sum)
						cross_count=h1+h2
						heuristic=cross_count*self.cost_between_mesh
					if((block_node1!=(sz-1))and(block_node1!=0)): 
						Sum=1
						for j in range(0, block_node1):
							Sum=Sum+self.N_sizes[j]+1
						h1=node1-Sum   #расчет номера перекрестки в блоке, содержащем этот перекресток
						h2=node2-Sum
						S1=h1+h2
						Sum=self.N_sizes[0]
						for j in range(1, (block_node1+1)): #здесь надо исправить!
							Sum=Sum+self.N_sizes[j]+1
						h1=abs(node1-Sum)
						h2=abs(node2-Sum)
						S2=h1+h2
						if(S1>S2):
							cross_count=S2
						else:
							cross_count=S1	
						heuristic=cross_count*self.cost_between_mesh  # +2*self.cost_between_blocks
					if ((node1_abs.number//self.N_size)!=(node2_abs.number//self.N_size)): #важно, чтобы перекрестки были в одно блоке!
						heuristic=heuristic+2*self.cost_between_blocks
				else:
					for j in range(node1, node2):
						if ((self.Nodes[j].crossroad==True)or(self.Nodes[j+1].crossroad==True)):  #-1
							heuristic = heuristic + self.cost_between_blocks
						if ((self.Nodes[j].crossroad==False) and (self.Nodes[j+1].crossroad==False)):  #-1
							heuristic = heuristic + self.cost_between_mesh
				row_node1=int((node1_abs.number-1)/self.N_size)
				row_node2=int((node2_abs.number-1)/self.N_size)
				row_difference=abs(row_node2-row_node1) 
				heuristic=heuristic+row_difference*self.cost_between_rows  #вернуть!
				H.append(heuristic+reachable[k].traveled_path)

		min=int(1000000*self.cost_between_mesh)
		for i in range(0, sz_reachable):
			if(H[i]<min):
				min=H[i]
		num=0
		for i in range(0, sz_reachable):
			if(H[i]==min):
				num=i
		return(reachable[num])



	def check_node_on_reachable(self, reachable, node): #True - входит, False - не входит
		sz=len(reachable)
		flag=False
		for i in range(0, sz):
			if(reachable[i].number==node.number):
				flag=True
				break
		return(flag)


	# для A-star
	def make_path(self, goal_node): #тут виснет при стартовой вершине не 0
		path=[]
		node=self.Nodes[goal_node.number]
		while (node.previous_node!=-1):
			path.append(node)
			node=self.Nodes[node.previous_node]
		path.append(node) #добавляем в маршрут стартовую вершину
		path.reverse()
		return(path)
	

	def A_star(self, start_node, goal_node):   #goal_node это объект класса Node
		reachable=[]
		explored=[]
		k=0
		reverse=False
		if(start_node.number==goal_node.number):
			path=[]
			path.append(self.Nodes[start_node.number])
			path.append(self.Nodes[goal_node.number])
			return(path)
		else:
			if(start_node.number>goal_node.number):
				tmp=start_node
				start_node=goal_node
				goal_node=tmp
				reverse=True
			if(start_node.number==0): # проблема где-то тут!
				node=self.Nodes[self.Nodes[0].branch_array[0].adjacted_node]
				self.Nodes[self.Nodes[0].branch_array[0].adjacted_node].previous_node=0 #на нулевую вершину указывает, но почему-то не работает
				sz=len(node.branch_array)
				for i in range(0, sz):
					reachable.append(self.Nodes[node.branch_array[i].adjacted_node])
				explored.append(self.Nodes[0])
				k=0	
			if(start_node.number!=0): #тут возможно тоже что-то с нулевой вершиной сделать?
				sz=len(start_node.branch_array)
				for i in range(0, sz):
					reachable.append(self.Nodes[start_node.branch_array[i].adjacted_node])
				explored.append(self.Nodes[start_node.number])
				k=1
			while(len(reachable)>0):
				node=self.Nodes[self.choose_node(reachable, goal_node).number]
				if(k==1):
					self.Nodes[node.number].previous_node=self.Nodes[start_node.number].number
					k=2

				if(node.number==goal_node.number):  
					if ((start_node.number == 0)and(goal_node.number == self.number_to_zero_node)):  # это костыль, это нужно, чтобы путь от 0-го до первого перекрестка на главной магистрали верно считался
						path = [self.Nodes[0], self.Nodes[self.number_to_zero_node]]
						if(reverse==True):
							path.reverse()
						return(path)

					path=self.make_path(goal_node)
					if(start_node.number==0):
						path.insert(0, self.Nodes[self.Nodes[0].branch_array[0].adjacted_node])
						path.insert(0, self.Nodes[0])

					if(reverse==True):
						path.reverse()
					return(path)

				reachable.remove(node)
				explored.append(node)
				adjacent_nodes=[]
				new_reachable_nodes=[] #этот массив не обновляется
				sz_adj_node=len(node.branch_array)	
				for i in range(0, sz_adj_node):
					adjacent_nodes.append(self.Nodes[node.branch_array[i].adjacted_node])

				sz_explored=len(explored) #вот это переписать надо
				new_reachable_nodes=adjacent_nodes
				for i in range(0, sz_explored):
					for j in range(0, len(new_reachable_nodes)):  #sz_adj_node):
						if(new_reachable_nodes[j].number==explored[i].number): 
							new_reachable_nodes.remove(explored[i]) #reachable
							break 

				sz_adj_node=len(new_reachable_nodes)
				for i in range(0, sz_adj_node): #проверить этот блок, удалить break, написать make_path, протестировать алгоритм
					if(self.check_node_on_reachable(reachable, new_reachable_nodes[i])==False): #т.е не знаем, как попасть в эту вершину 
						self.Nodes[new_reachable_nodes[i].number].previous_node=node.number
						reachable.append(self.Nodes[new_reachable_nodes[i].number])
				k=2
		not_path=[]
		not_path.append(-1)
		return(not_path)	

 
	def make_robot_action(self, path, N_mesh_size, floor, start_mesh, goal_mesh, to_end):
		#если goal_mesh=-1, то это перекресток, номер которого известен из path
		sz=len(path)
		robot_path=[]
		if(goal_mesh!=-1):
			udalennost=int(goal_mesh//N_mesh_size)%2
		else:
			udalennost=-1
		orientation_tmp=self.orientation
		if((start_mesh==-1)and(goal_mesh!=-1)and(path[0].number==path[1].number)):
			if((self.mode == 2) or (self.mode == 1)):
				if((orientation_tmp==1)and(udalennost==1)):
					print("ERROR!")
					return(robot_path) # вернет пустой массив
				if((orientation_tmp==1)and(udalennost==0)):
					if(floor==1):
						action=11
					if(floor==2):
						action=12
					self.orientation=3
				if((orientation_tmp==2)and(udalennost==1)):
					if(floor==1):
						action=1
					if(floor==2):
						action=2
					self.orientation=1
				if((orientation_tmp==2)and(udalennost==0)):
					if(floor==1):
						action=3
					if(floor==2):
						action=4
					self.orientation=3
				if((orientation_tmp==3)and(udalennost==1)):
					if(floor==1):
						action=11
					if(floor==2):
						action=12
					self.orientation=1
				if((orientation_tmp==3)and(udalennost==0)):
					print("ERROR!")
					return(robot_path) # вернет пустой массив
				if((orientation_tmp==4)and(udalennost==1)):
					if(floor==1):
						action=3
					if(floor==2):
						action=4
					self.orientation=1
				if((orientation_tmp==4)and(udalennost==0)):
					if(floor==1):
						action=1
					if(floor==2):
						action=2
					self.orientation=3
			robot_path.append(robot_path_node(action, 0))
			return(robot_path)
		if((start_mesh!=-1)and(goal_mesh==-1)and(path[0].number==path[1].number)):
			if((self.mode == 2) or (self.mode == 1)):
				return(robot_path)		

		if(path[0].number==path[1].number):
			if ((start_mesh>=0)and(goal_mesh>=0)): #т.е обе вершины не отрицательны (т.е стартовая и конечная точка - это именно ячейки, а не просто перекрестки)
				action=-1
				if (start_mesh==goal_mesh):
					if(floor==1):
						action=9
					if(floor==2):
						action=10			
				else:
					self.orientation=(self.orientation+2)%4
					if(floor==1):
						action=11
					if(floor==2):
						action=12
				robot_path.append(robot_path_node(action, 0))

		else:
			for i in range(0, (sz-1)):
				dx=path[i+1].number-path[i].number
				if((abs(dx)==self.N_size)or(abs(dx)==self.number_to_zero_node)): #если робот едет по главной магистрали, эта часть изменена 17 июля!
					if(dx>0):
						if(self.orientation==2):
							action=6
							counter=0 #1
							robot_path.append(robot_path_node(action, counter))
						if(self.orientation==3):
							action=18
							counter=0
							robot_path.append(robot_path_node(action, counter))
						if(self.orientation==4):
							action=5
							counter=0 #1
							robot_path.append(robot_path_node(action, counter))
						action=0
						counter=1
						robot_path.append(robot_path_node(action, counter))
						self.orientation=1
					if(dx<0):
						if(self.orientation==1):
							action=18 #разворот на 180 градусов, добавить в switch для робота и проверить
							counter=0 #1
							robot_path.append(robot_path_node(action, counter))
						if(self.orientation==2):
							action=5
							counter=0 #1
							robot_path.append(robot_path_node(action, counter))
						if(self.orientation==4):
							action=6
							counter=0 #1
							robot_path.append(robot_path_node(action, counter))
						action=0
						counter=1
						robot_path.append(robot_path_node(action, counter))
						self.orientation=3	

				if(abs(dx)==1): #если робот едет вдоль ряда ячеек
					if(dx>0):
						if(self.orientation==1):
							action=5
							counter=0 #1
							robot_path.append(robot_path_node(action, counter))
						if(self.orientation==3):
							action=6
							counter=0 #1
							robot_path.append(robot_path_node(action, counter))
						if(self.orientation==4):
							action=18 #данная команда используется только на первой итерации построения маршрута, и разворот производится ДО начала движения
							counter=0 #1
							robot_path.append(robot_path_node(action, counter))
						action=0
						counter=1
						robot_path.append(robot_path_node(action, counter))
						self.orientation=2
					if(dx<0):
						if(self.orientation==1):
							action=6
							counter=0 #1
							robot_path.append(robot_path_node(action, counter))
						if(self.orientation==2): #данная команда используется только на первой итерации построения маршрута, и разворот производится ДО начала движения 
							action=18
							counter=0 #1
							robot_path.append(robot_path_node(action, counter))
						if(self.orientation==3):
							action=5
							counter=0 #1
							robot_path.append(robot_path_node(action, counter))
						action=0
						counter=1
						robot_path.append(robot_path_node(action, counter))
						self.orientation=4
		
			if((start_mesh!=-1)or(goal_mesh!=-1)):
				orientation1=self.orientation #нужно для костыля в конце функции
				action=-1
				if (self.mode==1):
					if ((udalennost==0)and(self.orientation==2)):
						if(floor==1):
							action=3
						if(floor==2):
							action=4  # 2
						self.orientation=3
					if ((udalennost==1)and(self.orientation==2)):
						if(floor==1):
							action=1
						if(floor==2):
							action=2  # 4
						self.orientation=1
					if ((udalennost==0)and(self.orientation==4)):
						if(floor==1):
							action=1
						if(floor==2):
							action=2  #4
						self.orientation=3
					if ((udalennost==1)and(self.orientation==4)):
						if(floor==1):
							action=3
						if(floor==2):
							action=4  # 2
						self.orientation=1
					robot_path.append(robot_path_node(action, 1))
				if (self.mode==2):
					if((udalennost==0)and(self.orientation==2)):
						if(floor==1):
							action=3
						if(floor==2):
							action=4
						self.orientation=3
					if ((udalennost==1)and(self.orientation==2)):
						if(floor==1):
							action=1
						if(floor==2):
							action=2
						self.orientation=1
					if ((udalennost==0)and(self.orientation==4)):
						if(floor==1):
							action=1
						if(floor==2):
							action=2
						self.orientation=3
					if ((udalennost==1)and(self.orientation==4)):
						if(floor==1):
							action=3
						if(floor==2):
							action=4 
						self.orientation=1
					robot_path.append(robot_path_node(action, 1)) 
		if(to_end==True):
			elem=robot_path[len(robot_path)-1]
			if(self.mode==2):
				if((elem.action==4)or(elem.action==3)): #ксли уже 5 или 6, то просто пройдет мимо
					robot_path[len(robot_path)-1].action=6  #6
				if((elem.action==2)or(elem.action==1)):
					robot_path[len(robot_path)-1].action=5
			if(self.mode==1):  #где-то до этого неверно определяет 4 и 2 на последнем этапе (перед 0-м перекрестком). поэтому вот такой костыльы
				if ((elem.action==4)or(elem.action==3)): #ксли уже 5 или 6, то просто пройдет мимо
					robot_path[len(robot_path)-1].action=5
				if((elem.action==2)or(elem.action==1)):
					robot_path[len(robot_path)-1].action=6
				
		robot_action=[]
		sz=len(robot_path)
		i=0
		while(i<sz):
			if(robot_path[i].action>0):
				robot_action.append(robot_path[i])
			if(robot_path[i].action==0):
				count=0
				while (robot_path[i].action==0): #здесь выход за границу
					count=count+1
					i=i+1
					if(i==sz):
						break
				if(i==sz):
					i=i-1
				robot_action.append(robot_path_node(robot_path[i].action, count))
				i=i+1
			else:
				i=i+1
	
		sz=len(robot_action) #в А стар поступает вершина с номером -1, и возвращает действие = -1. но путь к базе это команда 0, поэтому меняем -1 на 0
		for i in range(0, sz):
			if(robot_action[i].action==-1):
				robot_action[i].action=0
			
		if(path[sz-1].number==0):#костыль, если конечная вершина 
			robot_path.append(robot_path_node(0, 1)) #может быть, вместо robot_path robot_action? 
	
		if ((start_mesh==-1)and(goal_mesh==-1)):
			if((robot_action[len(robot_action)-1].action==1)or(robot_action[len(robot_action)-1].action==2)or(robot_action[len(robot_action)-1].action==3)or(robot_action[len(robot_action)-1].action==4)):
				robot_action[len(robot_action)-1].action=0
				self.orientation = orientation1
		return(robot_action)


	def get_path_nodes(self, path): #строит маршрут, состоящий из номеров неповторяющихся подряд перекрестков (нужно для определения роботом перекрестка с препятствием)
		sz=len(path)
		path_nodes=[]
		tmp=path[0]
		path_nodes.append(tmp)
		for i in range(1, sz):
			if(path[i]!=tmp):
				tmp=path[i]
				path_nodes.append(tmp)
		return(path_nodes)

	#строит полный маршрут, включает в себя построение 2 или 3 отрезков маршрута с помощью A-star, возвращает одним списком массив неповторяющихся номеров перекрестков, а также массив команд для робота
	def make_full_path(self, start_node, start_mesh, mesh_arr, end_node, end_mesh, floor_arr): #массив ячеек, номер стартового перекрестка, массив номеров ячеек с ящиками (1 или 2 элемента), номер конечного перекрестка, массив номеров этажей (1 или 2 элемента). Возвращает 
		self.list.clear() # очистка от предыдущего маршрута
		if((start_node==end_node)and(len(mesh_arr)==0)): 
			self.list.append(0)
			return
		if(len(mesh_arr)==0): #путь от перекрестка до перекрестка!
			path = self.A_star(self.Nodes[start_node], self.Nodes[end_node])
			if((len(path)==1)and(path[0]==-1)):
				self.list.append(-1) #robot_path_node(-1, -1))
				self.list.append(0)
				self.list.append(start_node)
				self.list.append(end_node)
				return
			nodes_sz=len(self.Nodes)
			for i in range(0, nodes_sz):
				self.Nodes[i].previous_node=-1
			action=self.make_robot_action(path, sum(self.N_sizes), 0, -1, -1, True)
			for i in range(0, len(path)):
				self.Nodes[path[i].number].previous_node=-1
		else:
			#1, путь до первой ячейки
			node1=start_node #если робот стоит между перекрестками, то вводим тот перекресток, перед которым лежит препятствие(если его нельзя объехать), поэтому на объезд препятствий оставляем эту проблему
			mesh1=start_mesh
			mesh2=mesh_arr[0]    # в этой функции надо убрать start_mesh и end_mesh!
			node2=int(self.get_crossroad(int(mesh2)))
			path1 = self.A_star(self.Nodes[node1], self.Nodes[node2])
			if((len(path1)==1)and(path1[0]==-1)):
				self.list.append(-1)
				self.list.append(1)
				return
			nodes_sz=len(self.Nodes)
			for i in range(0, nodes_sz):
				self.Nodes[i].previous_node=-1
			action1=self.make_robot_action(path1, sum(self.N_sizes), floor_arr[0], mesh1, mesh2, False)
			for i in range(0, len(path1)): #mesh1 ????
				self.Nodes[path1[i].number].previous_node=-1
			path=path1
			action=[]
			action=action1
			#2, путь до второй ячейки или домой (в данном случае до второй ячейки)
			if (len(mesh_arr)==2):
				mesh1=mesh_arr[0]
				mesh2=mesh_arr[1]
				node1=int(self.get_crossroad(int(mesh1)))
				node2=int(self.get_crossroad(int(mesh2)))
				path2 = self.A_star(self.Nodes[node1], self.Nodes[node2]) 
				if((len(path2)==1)and(path2[0]==-1)):
					self.list.append(-1)
					self.list.append(2)
					return
				for i in range(0, nodes_sz):
					self.Nodes[i].previous_node=-1
				action2=self.make_robot_action(path2, sum(self.N_sizes), floor_arr[1], mesh1, mesh2, False)
				path=path+path2
				action=action+action2
			#3, путь домой
			if (len(mesh_arr)==2):
				mesh1=mesh_arr[1]
			else:
				mesh1=mesh_arr[0]
			mesh2=end_mesh
			node2=end_node
			node1=int(self.get_crossroad(int(mesh1)))
			node2=end_node #int(self.get_crossroad(int(mesh2)))   #это изменего 29 августа!
			path3 = self.A_star(self.Nodes[node1], self.Nodes[node2])
			if((len(path3)==1)and(path3[0]==-1)):
				self.list.append(-1)
				self.list.append(3)
				return
			for i in range(0, nodes_sz):
				self.Nodes[i].previous_node=-1
			action3=self.make_robot_action(path3, sum(self.N_sizes), 1, mesh1, mesh2, True)   #на конечном участке floor всегда должен быть равен 2, иначе не будет работать костыль, связанный с заменой 2/4 на 6/5
			path=path+path3
			action=action+action3
		self.list.append(len(action))
		path_without_repetitions=self.get_path_nodes(path)
		self.list=self.list+action+path_without_repetitions
		#return(list) #list - список, состоит из robot_action и path


	def get_action_size(self):
		return(self.list[0])


	def get_error_number(self):
		error = []
		if(self.list[0]==-1):  #если есть ошибка, возвращаем ее номер и 2 перекрестка, если они есть. иначе возвращаем пустой массив
			error.append(self.list[1])
			if(self.list[1]==0):
				error.append(list[2])
				error.append(list[3])
			return(error)
		else:
			return(error)


	def get_action(self):
		robot_action=[]
		if(self.list[0]>0): # проверка на всякий случай, то же самое делается в дальнейшем коде
			for i in range(1, self.list[0]+1):
				robot_action.append(self.list[i])
		return(robot_action)


	def get_path(self):
		path=[]
		if(self.list[0]>0): # проверка на всякий случай, то же самое делается в дальнейшем коде
			for i in range(self.list[0] + 1, len(self.list)):
				path.append(self.list[i])
		return(path)


	def get_count_of_mesh(self):
		return(self.count_of_mesh) #помним, что нумерация с нуля!!!

	def set_orientation(self, orient):
		self.orientation = orient

	def get_max_floor(self):
		return(self.max_floor)

	def Print(self): # для отладки полезно!
		for i in range(0, len(self.Nodes)):   #печать вершин графа
			print("Number = ", self.Nodes[i].number)
			print("flag = ", self.Nodes[i].crossroad)
			print("prev = ", self.Nodes[i].previous_node)
			sz=len(self.Nodes[i].branch_array)
			for j in range(0, sz):
				print("Branch = ", self.Nodes[i].branch_array[j].adjacted_node)
				print("Branch.cost = ", self.Nodes[i].branch_array[j].cost)
			print(" ")

class Test:
	def __init__(self):
		self.sklad = Sklad(2, 2, [1, 1], 1.5, 4, 1, 2, 2, 1)
		self.mesh_arr=[0, 3]
		self.floor_arr=[1, 2]
		self.sklad.make_full_path(0, -1, self.mesh_arr, 0, -1, self.floor_arr)
		self.path = self.sklad.get_path()


	def get_count_passed_mesh(self, robot_answer): #возвращает количество успешно пройденных ячеек
		len_arr_ans=len(robot_answer)
		if((robot_answer[1].n2 >= 0)and(robot_answer[0] == 0)): #Препятствие между 2 перекрестками и оно есть!
			if(len(self.mesh_arr)==0):
				return(0)
			node1 = self.sklad.get_crossroad(self.mesh_arr[0])
			mesh_count=0
			sz=robot_answer[len_arr_ans-1].n1
			i=0
			while((i<sz)and(node1 != self.path[i].number)):
				i=i+1
			if(node1 == self.path[i].number): #если ячейка все таки есть, а не произошло выхода из цикла по причине дохождения до sz
				mesh_count=1
			if((len(self.mesh_arr)==2)): #and(i<sz)):
				node2 = self.sklad.get_crossroad(self.mesh_arr[1])
				while((i<sz)and(node2 != self.path[i].number)): # за границы диапазона не выйдет, так как sz<len(path)!
					i=i+1
				if(node2 == self.path[i].number): #если ячейка все таки есть, а не произошло выхода из цикла по причине дохождения до szs
					mesh_count=2
			return(mesh_count)
		if((robot_answer[1].n2 < 0)and(robot_answer[0] == 0)): #Препятствие перед ячейкой и оно есть!
			mesh_count=0
			if(len(self.mesh_arr)==2):
				node1=self.sklad.get_crossroad(self.mesh_arr[0])
				node2=self.sklad.get_crossroad(self.mesh_arr[1])
				sz=robot_answer[1].n1
				if(node1==node2): #ячейки напротив одного перекрестка
					i=0
					while((i<sz)and(node1!=self.path[i].number)):
						i=i+1
					if(node1==self.path[i].number):#если ячейка все таки есть, а не произошло выхода из цикла по причине дохождения до sz

						if(robot_answer[1].n2==mesh_arr[0]): #перед 1-й ячейкой препятствие
							mesh_count=0
						if(robot_answer[1].n2==mesh_arr[1]): #перед 2-й ячейкой препятствие
							mesh_count=1
				if(node1!=node2):
					i=0
					while((i<sz)and(node1!=self.path[i].number)):
						i=i+1
					barrier=False
					if(i==robot_answer[1].n1):
						mesh_count=0
						barrier=True
					while((i<sz)and(node2!=self.path[i].number)):
						i=i+1
					if((i==robot_answer[1].n1)and(barrier==False)):
						mesh_count=1
			if(len(self.mesh_arr)==1):
				mesh_count=0	
			return(mesh_count) #сдвинуть вниз!
		if(robot_answer[0]==1):
			return(len(self.mesh_arr))


	"""def get_mesh_number(self, array_result): # возвращает - число успешно взятых товаров! или таки номер?????????????
		if(array_result[1]==-1):
			print("В get_mesh_number получено отрицательное значение ячейки с робота")
			return
		node=self.path[array_result[1]].number
		res=[]
		if(len(self.mesh_arr)==2):
			n1=self.sklad.get_crossroad(self.mesh_arr[0])
			n2=self.sklad.get_crossroad(self.mesh_arr[1])
			if(node==n1):
				res.append(self.mesh_arr[0])
				res.append(self.floor_arr[0])
				return(res)
			if(node==n2):
				res.append(self.mesh_arr[1])
				res.append(self.floor_arr[1])
				return(res)
		if(len(self.mesh_arr)==1):
			n1=self.sklad.get_crossroad(self.mesh_arr[0])
			if(node==n1):
				res.append(self.mesh_arr[0])
				res.append(self.floor_arr[0])
				return(res)""" 



test = Test()
robot_answer = [0, edge(0, 1), edge(4, 5)]
#print(test.get_mesh_number(robot_answer))
print(test.get_count_passed_mesh(robot_answer))


