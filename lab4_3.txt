# python lab4_3.txt

import torch
import torch.nn as nn
import torchvision
import matplotlib.pyplot as plt

# Load MNIST dataset
train_dataset = torchvision.datasets.MNIST(root='./data', train=True, transform=torchvision.transforms.ToTensor(), download=True)
test_dataset = torchvision.datasets.MNIST(root='./data', train=False, transform=torchvision.transforms.ToTensor(), download=True)

#Create data loaders
train_loader = torch.utils.data.DataLoader(train_dataset, batch_size=128, shuffle=True)
test_loader = torch.utils.data.DataLoader(test_dataset, batch_size=128, shuffle=False)

#Define encoder and decoder layers
encoder_layers = nn.Sequential(nn.Linear(2828, 128), nn.ReLU(), nn.Linear(128, 16), nn.ReLU())
decoder_layers = nn.Sequential(nn.Linear(16, 64), nn.ReLU(), nn.Linear(64, 2828), nn.Sigmoid())

#Define autoencoder model using encoder and decoder layers
autoencoder = nn.Sequential(encoder_layers, decoder_layers)

#Define loss function, optimizer, and device
critery = nn.BCELoss()   #nn.MSELoss()
optimizer = torch.optim.Adam(autoencoder.parameters(), lr=0.001)
device = torch.device('cpu')

#Train autoencoder model
num_epochs = 10
for epoch in range(num_epochs):
    for data in train_loader:
        img, _ = data
        img = img.to(device)
        output = autoencoder(img.view(-1, 784))
        loss = critery(output, img.view(img.size(0), -1))
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
    print(f'Epoch [{epoch+1}/{num_epochs}], Loss: {loss.item():.4f}')

#Test autoencoder model
with torch.no_grad():
    for data in test_loader:
        img, _ = data
        img = img.to(device)
        output = autoencoder(img.view(img.size(0), -1))
        loss = critery(output, img.view(img.size(0), -1))
        fig, axes = plt.subplots(nrows=2, ncols=10, sharex=True, sharey=True, figsize=(25,4))
        for images, row in zip([img, output], axes):
            for img, ax in zip(images, row):
                ax.imshow(img[0], cmap='gray')
                ax.axis('off')
                fig.suptitle('Original Images and Reconstructed Images')
        plt.show()
        print(f'Test Loss: {loss.item():.4f}')
        break